## js中的数字表示

在js中，整数默认都是有符号的，比如下面的代码

var a = -1;

a在内存中的表示形式为32个1，其中最高位的1表示符号位，但是在有些场合需要用到无符号整数，可以这样处理：

a = a >>> 0

表示无符号右移0位，这样a就变成无符号整数了，注意js中只能以这种方式创建无符号整数。

在js的算术操作中，都是先将数字转成32位的有符号浮点数，再进行操作，操作之后再转成整数。这也是0.1 + 0.2 != 0.3 的原因。


### 机器数和真值
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1。

### 原码, 反码, 补码

1. 原码
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001，[-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

[1111 1111 , 0111 1111]，即[-127 , 127]

原码是人脑最容易理解和计算的表示方式.

2. 反码
反码的表示方法是:

正数的反码是其本身

**负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.**

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

3. 补码
补码的表示方法是:

正数的补码就是其本身

**负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)**

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.


### 为何要使用原码, 反码和补码

原码只是人脑的思考的方式，但是不适合计算机处理，计算机的减法，其实就是加一个负数，为了方便符号位的计算，所以有了补码和反码。

计算十进制的表达式1-1，,如果用人脑的思维方式，得到的是错误的结果：
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

反码的计算方式, 结果的真值部分是正确的，但符号位有问题：
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

补码的计算方式，结果和符号位都正确：
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原 = 0



## 位操作

JavaScript的所有位操作都是先将操作对象转化为32位有符号数进行的。具体的细节可以去查Ecma-262规范（JavaScript 的正式名称是 "ECMAScript"，其语法由Ecma-262规范描述）。

& 按位与，将任何数字x与0进行按位与运算将得出0。
| 按位或，将任何数字x与0进行按位与运算将得出x。
~ 按位非，任何数字x的运算结果都是-(x + 1)。例如，〜-5运算结果为4。
^ 按位异或，都为1和都为0时为0，否则为1，任何数和本身异或则为0，任何数和 0 异或是本身。
a ^ b ^ c = a ^ c ^ b


### <<左移

```js
a = 5 // 00000000000000000000000000000101
a << 2 = 20 // 00000000000000000000000000010100
a << 33 = a << 1 = 10 // 00000000000000000000000000001010
-5<<2 = -20，-5<<33 = -10
x << y = x * (2^y)
// 左移位数Y大于等于 32 时，实际左移位数为  Y - 32
X << 33 = X << 1
```

### 右移

对于其移动规则只需记住符号位不变，左边补上符号位即按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。
```js
a = 20 // 00000000000000000000000000010100
a >> 2 = 5 // 00000000000000000000000000000101
a >> 5 = 0 // 00000000000000000000000000000000

-20 >> 2 = -5，-20 >> 5 = -1
-20 的原码：100000000000000000000000000010100
-20 的反码：111111111111111111111111111101011 // 符号位不变，其他位取反
-20 的补码：111111111111111111111111111101100 // 符号位不变，加1

补码右移两位：111111111111111111111111111111011 // 符号位不变，因为是-数，所以高位是补1
补码减1得反码：111111111111111111111111111111010
反码取反得原码：10000000000000000000000000010101 = -5
```
任何正数右移负数位都是0，任何负数右移负数位都是-1。

### 无符号右移

20>>>2 = 5，20 >>> 5 = 0 正数时，跟右移结果一致。
-20>>>2 = 1073741819，-20 >>> 5 = 134217727。

**注：没有无符号左移**


### 按位操作符的使用

1. 使用&运算符判断一个数的奇偶
```js
0 & 1 = 0, 1 & 1 = 1
// 1只有最后一位是1，其余位是0，而偶数的最后一位肯定是0，奇数的最后一位肯定是1
// 那么:
// 偶数 & 1 = 0, 比如：2 & 1 = 0
// 奇数 & 1 = 1, 比如：3 & 1 = 1
```

2. 使用~~，>>,<<,>>>,|来取整
```js
~~3.14 = 3
3.14 >> 0 = 3
3.14 << 0 = 3
3.14 | 0 = 3
3.14 >>> 0 = 3(>>>不可对负数取整)
// 注意：~~-3.14 = -3 其它的一样
```

3. 利用^来完成比较两个数是否相等
```js
1 ^ 1 = 0
1 ^ 不是1的数 != 0
// 所以同一个数 ^ 同一个数等于0，否则不等于0
```

4. 使用^来完成值交换
```js
a = 1
b = 2
a ^= b
b ^= a
a ^= b
// 结果a=2，b=1
```

6、使用&,>>,|来完成rgb值和16进制颜色值之间的转换
```js
// 16进制颜色值转RGB：
function hexToRGB(hex){
    // 0x 开头代表16进制
    var hex = hex.replace("#","0x"),
        r = hex >> 16,
        g = hex >> 8 & 0xff,
        b = hex & 0xff;
    return `rgb(${r},${g},${b})`;
}
// RGB转16进制颜色值：
function RGBToHex(rgb){
    var rgbArr = rgb.split(/[^\d]+/),
        color = rgbArr[1]<<16 | rgbArr[2]<<8 | rgbArr[3];
    return "#" + color.toString(16);
}
// 运行hexToRGB("#ffffff")返回"rgb(255,255,255)"
// 运行RGBToHex("rgb(255,255,255)")返回"#ffffff"
```


## 无符号与有符号数的转换

通过使用无符号右移运算符，位动位数为0，可以将32位有符号整数，转化为32位无符号整数。
通过使用左移运算符，位动位数为0，可以将32位无符号整数，转化为32位有符号整数。
```js
var signed = -1, unsigned;
unsigned = signed >>> 0; // 无符号右移0位，其实就是转成无符号数
alert ("unsigned="+unsigned); // unsigned=4294967295

signed = unsigned << 0;
alert ("signed="+signed); // signed=-1
```

[二进制的奥秘](https://www.cnblogs.com/goahead--linux/p/10904701.html)
